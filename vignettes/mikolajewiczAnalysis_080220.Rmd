---
title: "Paper Analysis"
author: "Nicholas Mikolajewicz"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r load XcalRep, message = F, warning = F}
rm(list = ls()) # clear enviroment
library(XcalRep)
library(dplyr)
```

```{r}

# load data into global enviroment 
df.qc1 <-qc1
df.efp <- efp
df.invivo <- invivo


# df.invivo$phantom[df.invivo$phantom == "radius"] <- "patient"
# df.invivo$phantom[df.invivo$phantom == "tibia"] <- "patient"



# combine datasets (ensure replicate sets aren't mixed)
df.qc1$replicateSet <- paste("q", df.qc1$replicateSet, sep = "")
df.efp$replicateSet <- paste("e", df.efp$replicateSet, sep = "")
df.invivo$replicateSet <- paste("v", df.invivo$replicateSet, sep = "")

all.data <- bind_rows(df.qc1, df.efp)

which.features.missing <-  colnames(all.data)[!(colnames(all.data) %in% colnames(df.invivo))]
for (i in 1:length(which.features.missing)){
  df.invivo[, which.features.missing[i]] <- NA
}
match.ind <- match(colnames(all.data), colnames(df.invivo))
df.invivo <- df.invivo[, match.ind]

all.data <- bind_rows(all.data, df.invivo)

# show table header
showTable(all.data, head.flag = T) 


# TODO
# Ensure that replicate sets aren't merged or mixed together
# Use TT.vBMD to calibrate other parameters (e.g., QC1 to calibration Ct.vBMD and Tb.vBMD)

```


```{r}
# create calibration object using incomplete data input
co <- createCalibrationObject(all.data)

# NOTEs
# how to name NA sections for in vivo data if imported alongside phantom data?
# How does analysis behave is phantom type is NOT specified?
# explicitly define rescanSet
```

```{r get assay}
# get current assay
getAssay(co)
```

```{r get datasets}
# get existing datasets
getDatasets(co)
```


```{r get features}
# get list of available features
available.features <- getFeatures(object = co, which.assay = "input")

# show feature names
names(available.features)
```



```{r n unique features}
# get table of unique feature type counts
N.features <- getUniqueFeatureCount(object = co)

showTable(N.features) 
```


```{r available timepoints}
available.features[["timePoint"]]
```

```{r available phantom}
available.features[["phantom"]]
```

```{r available sections}
available.features[["section"]]
```

```{r available parameters}
available.features[["parameter"]]
```




```{r these features}
analyze.these <- analyzeWhich(co,
                              omit.sections = "1",
                              omit.sites = c(""))
str(analyze.these)
```




```{r preprocess data, warning = F}
co <- preprocessData(object = co, 
                      analyze.which = analyze.these, 
                      new.assay.name = "preprocessed.data",
                      which.assay = "input")

# TODO
# What happens when multiple phantoms are alayzed together?
```


```{r get all assays}
getAssay(co, which.assays = "all")
```

```{r get default assay}
getAssay(co, which.assays = "default")
```


```{r svp analysis, warning = F, message = F}
co <- svpAnalysis(co, 
                   which.data = "uncalibrated",
                   verbose = F)
```


```{r get svp results}

# retrieve stored results (as datatables)
svp.results.uncalibrated <-getResults(object = co, 
                                which.results = "svp") 

# see what tables were generated 
names(svp.results.uncalibrated)

# show rms statistics
showTable(svp.results.uncalibrated[["rms.statistics"]], as.dt = T)

```


```{r}

# meanVarPlot(co, 
#             which.data = "uncalibrated", 
#             which.plot = "box", 
#             which.phantom = "EFP",
#            
#            )
# 
# meanVarPlot(co,
#             which.data = "uncalibrated",
#             outliers = F,
#             which.plot = "scatter",
#             which.phantom = "EFP")


# Note ENSURE THAT phantom replicate scans are properly grouped (e.g., for in vivo replicates)
```

```{r}
# showTable(svp.results.uncalibrated[["replicate.statistics"]])
```


```{r svp plot scanner, fig.width= 15, fig.height = 5, warning = F, message=F}
# 
# svpPlot(co,
#         which.data = "uncalibrated",
#         group.by = c("scanner"),
#         which.phantom = c("EFP"),
#         which.parameter = c("Tt.vBMD", "Tb.vBMD", "Ct.vBMD.XCT2", "Ct.Th.XCT2", "Ct.Ar.XCT2", "Tb.Ar"),
#         var2plot = "cv",
#         outliers = F,
#         color.begin = 0.1,
#         color.end = 0.5,
#         color.option = "cividis",
#         point.alpha = 1,
#         point.size = 3,
#         txt.size = 15,
#         jitter.width = 0.03,
#         color.begin.v2 = 0,
#         color.end.v2 = 1,
#         color.option.v2 = "viridis")

# svpPlot(co,
#         which.data = "uncalibrated",
#         group.by = c("phantom"),
#         which.phantom = c("EFP", "patient"),
#         which.parameter = c("Tt.vBMD", "Tb.vBMD", "Ct.vBMD.XCT2", "Ct.Th.XCT2", "Ct.Ar.XCT2", "Tb.Ar"),
#         var2plot = "cv",
#         outliers = F,
#         color.begin = 0.1,
#         color.end = 0.5,
#         color.option = "cividis",
#         point.alpha = 1,
#         point.size = 3,
#         txt.size = 15,
#         jitter.width = 0.03,
#         color.begin.v2 = 0,
#         color.end.v2 = 1,
#         color.option.v2 = "viridis")

        # which.parameter = c("Tt.vBMD", "Tb.vBMD", "Ct.vBMD.XCT2", "Ct.Th.XCT2", "Ct.Ar.XCT2", "Tb.Ar"),

# "Ct.Po",  
svpPlot(co,
        which.data = "uncalibrated",
        group.by = c("phantom"),
        which.phantom = c("radius", "tibia"),
        which.parameter = c("Tt.vBMD", "Tb.vBMD", "Ct.vBMD.XCT2", "Ct.Th.XCT2", "Ct.Ar.XCT2", "Tb.Ar", "Tb.BV/TV", "Tb.N", "Tb.Sp", "Tb.Th", "inhomogeneity.Tb.network",  "peripheral.medullary.Tb.BD", "app.modulus", "stiffness",  "failure.load"),
        var2plot = "cv",
        outliers = F,
        color.begin = 0.5,
        color.end = 1,
        color.option = "cividis",
        point.alpha = 1,
        point.size = 3,
        txt.size = 15,
        jitter.width = 0.03,
        color.begin.v2 = 0,
        color.end.v2 = 1,
        color.option.v2 = "viridis")


svpPlot(co,
        which.data = "uncalibrated",
        group.by = c("phantom"),
        which.phantom = c("radius", "tibia"),
        which.parameter = c("Ct.Po"),
        var2plot = "cv",
        outliers = F,
        color.begin = 0.5,
        color.end = 1,
        color.option = "cividis",
        point.alpha = 1,
        point.size = 3,
        txt.size = 15,
        jitter.width = 0.03,
        color.begin.v2 = 0,
        color.end.v2 = 1,
        color.option.v2 = "viridis")

 
# "app.modulus" "stiffness"  "failure.load"

# RESUME HERE
```

```{r, fig.width= 15, fig.height = 5, warning = F, message=F}


svpPlot(co, 
        which.data = "uncalibrated",
        group.by = "phantom",
        which.phantom = c("EFP", "radius", "tibia"),
        outliers = F,
        color.begin = 0.1, 
        color.end = 0.9,
        txt.size = 15,
        xlab.hjust = 1,
        point.alpha = 0.1,
        xlab.direction = 45)

```


```{r reference site, warning = F, message = F}

# par4study <- c("Tt.vBMD", "Ct.vBMD.XCT2", "Tb.vBMD", "Ct.Ar.XCT2", "Ct.Th.XCT2", "Tt.Ar",  "Tb.Ar", "Ct.Pm")

par4study <- c("Tt.vBMD")
# par4study <- c("Tt.vBMD",  "Ct.vBMD.XCT2",   "Ct.Th.XCT2", "Tt.Ar",  "Ct.Pm")

reference.scores <- identifyReference(co, 
                                    which.phantom = c("EFP", "QC1"),
                                    which.parameter = par4study,
                                    pool.phantoms = T,
                                    return.scores = T)

pool.scores <- reference.scores[["pool"]]

showTable(pool.scores, as.dt = T)

reference.site <- identifyReference(co, 
                                    which.phantom = c("EFP", "QC1"),
                                    which.parameter = par4study,
                                    pool.phantoms = T,
                                    return.scores = F)
reference.site

```

```{r consistency tile, fig.width = 6, fig.height = 6, warning = F, message=F}

# par4study <- c("Tt.vBMD", "Ct.vBMD.XCT2", "Tb.vBMD", "Ct.Ar.XCT2", "Ct.Th.XCT2", "Tt.Ar",  "Tb.Ar", "Ct.Pm")
# par4study <- c("Tt.vBMD",  "Ct.vBMD.XCT2",   "Ct.Th.XCT2", "Tt.Ar",  "Ct.Pm")

par4study <- c("Tt.vBMD")
consistencyPlot(co, 
                var2plot = "mse",
                which.plot = "tile",
                which.phantom = "EFP",
                group.by = "scanner",
                which.parameter = par4study, 
                show.tile.value = T)

consistencyPlot(co, 
                var2plot = "mse",
                which.plot = "tile",
                which.phantom = "QC1",
                group.by = "scanner",
                which.parameter = par4study, 
                show.tile.value = T)
```

Alternatively, `box` plot shows the overall ranking once parameter-specific ranks are pooled. 
```{r consistency box, fig.width = 6, fig.height = 4, warning = F, message=F}
# Display table of MSE estimates (used to identify reference site)
# showTable(consistencyAnalysis(co), cast.as.dt = T)

consistencyPlot(co, 
                var2plot = "mse",
                which.phantom = "EFP",
                which.plot = "box")
```





```{r}

getAssay(co, which.assays = "all")
co <- cloneAssay(co, which.assay = "preprocessed.data", cloned.assay.name = "EFP")
co <- cloneAssay(co, which.assay = "preprocessed.data", cloned.assay.name = "QC1")
```


```{r fit calibration, warning = F, message=F}
# fit calibration curves
co <- fitCalibration(co, 
                     which.assay = "EFP",
                     reference.site = "Oregon",
                     which.phantom = "EFP",
                     omit.parameter = c("Ct.Th", "Ct.vBMD.XCT1"),
                     sig.intercept.only = F,
                     x.fold.val = F)

getCalibrationInfo(co, which.assay = "EFP")

co <- fitCalibration(co, 
                     which.assay = "QC1",
                     reference.site = "Oregon",
                     which.phantom = "QC1",
                     sig.intercept.only = F,
                     x.fold.val = F)

getCalibrationInfo(co, which.assay = "QC1")

```

```{r get calibration results, warning = F, message=F}

# retrieve calibration results (as datatables)
calibration.results.qc1 <-getResults(object = co, 
                                which.results = "calibration",
                                which.assay = "QC1",
                                format = 'df') 

calibration.results.efp <-getResults(object = co, 
                                which.results = "calibration",
                                which.assay = "EFP",
                                format = 'df') 


# see what tables were generated 
names(calibration.results.qc1)
names(calibration.results.efp)

# show rms statistics
showTable(calibration.results.qc1[["calibration.equations"]], as.dt = T)

showTable(calibration.results.efp[["calibration.equations"]], as.dt = T)
```


```{r equation comparison}



```


```{r, warning=F, message=F}

compareCalibrationPlot(co, 
                    which.assay.1 = "QC1", 
                    which.assay.2 = "EFP", 
                    which.parameter = c("Tt.vBMD"),
                    which.plot = "box",
                    color.begin = 0.1,
                    color.end = 0.5,
                    point.size = 4, point.alpha =0.8)



compareCalibrationPlot(co, 
                    which.assay.1 = "QC1", 
                    which.assay.2 = "EFP", 
                    which.parameter = c("Tt.vBMD"),
                    which.plot = "scatter",
                    color.begin = 0.1,
                    color.end = 0.5,
                    point.size = 4, point.alpha =0.8)

```

### 5.4 Visualization

To visualize the calibration curves, use the `calibrationPlot` function. 
```{r calibration curves, fig.width = 7, fig.height = 5}
calibrationPlot(co, 
                which.assay = "QC1",
                 which.parameter = "Tt.vBMD", 
                 return.plt.handle = F, 
                 color.option = "A", color.begin = 0, color.end = 0.5)


# calibrationPlot(co, 
#                 which.assay = "EFP",
#                  which.parameter = "Tt.vBMD", 
#                  return.plt.handle = F, 
#                  color.option = "A", color.begin = 0, color.end = 0.5)
```


```{r}

calibrationPlot(co, 
                which.assay = "EFP",
                 which.parameter = "Tt.vBMD", 
                 return.plt.handle = F, 
                 color.option = "A", color.begin = 0, color.end = 0.5)
```



```{r calibrate data}
# calibrate data
co <- calibrateData(co, 
                    which.assay = "QC1",
                    verbose = F)

co <- calibrateData(co, 
                    which.assay = "EFP",
                    verbose = F)
```

The current `Assay` now contains two datasets; `uncalibrated` and `calibrated`.
```{r get data calibration}
# show available datasets
getDatasets(co, which.assay = "QC1")
```



```{r diagnostic line, fig.width= 7, fig.height = 4}
diagnosticPlot(co, which.assay = "QC1", which.parameter = "Tt.vBMD", which.plot = "line")

diagnosticPlot(co, which.assay = "EFP", which.parameter = "Tt.vBMD", which.plot = "line")
```


```{r diagnostic bar, fig.width= 8, fig.height = 7, message = F}
# diagnosticPlot(co, which.parameter = "Tb. vBMD", which.plot = "bar", fix.axis = T)

diagnosticPlot(co, which.assay = "QC1", which.parameter = "Tt.vBMD", which.plot = "bar", fix.axis = T)

diagnosticPlot(co, which.assay = "EFP", which.parameter = "Tt.vBMD", which.plot = "bar", fix.axis = T)
```


```{r residuals, fig.width= 7, fig.height = 5, message = F}
diagnosticPlot(co, which.assay = "QC1", which.parameter = "Tt.vBMD", which.plot = "dif", fix.axis = T)

diagnosticPlot(co, which.assay = "EFP", which.plot = "dif", fix.axis = T)
# \
#stratfiy dif by time and site?
```

```{r}

diagnosticPlot(co, which.assay = "QC1", which.parameter = "Tt.vBMD", which.plot = "residual", fix.axis = T)

```


```{r}


co <- mvpAnalysis(co, 
                  which.data = "all",
                  which.assay = "EFP",
                  which.phantom = c("EFP", "QC1"), 
                  verbose = F)

co <- mvpAnalysis(co, 
                  which.data = "all",
                  which.assay = "QC1",
                  which.phantom = c("EFP", "QC1"), 
                  verbose = F)


# retrieve stored results (as datatables)
mvp.results.qc1 <-getResults(object = co, 
                         which.assay = "QC1",
                                which.results = "mvp",
                                format = 'dt') 


mvp.results.efp <-getResults(object = co, 
                         which.assay = "EFP",
                                which.results = "mvp",
                                format = 'dt') 

# show rms statistics for calibrated data
showTable(mvp.results.qc1[["rms.statistics"]])
```



```{r, fig.width= 10}

# RESUME HERE (8:26 pm, 090220)

mvpPlot(co,
        outliers =F,
        var2plot = "cv",
        which.data = "all",
        which.assay = "EFP",
        group.by = "phantom",
        which.parameter = "Tt.vBMD",
        which.precision = "all",
        color.begin = 0.1,
        color.end = 0.5,
        point.alpha = 0.1,
        jitter.width = 0.1,
        show.rms.statistic = T)

# 
# mvpPlot(co,
#         outliers = F,
#         var2plot = "cv",
#         which.data = "all",
#         which.assay = "QC1",
#         group.by = "phantom",
#         which.parameter = "Tt.vBMD",
#         which.precision = "all",
#         color.begin = 0.1,
#         color.end = 0.5,
#         point.alpha = 0.1,
#         jitter.width = 0.1,
#         show.rms.statistic = T)


mvpPlot(co,
        outliers = F,
        var2plot = "cv",
        which.data = "all",
        which.assay = "EFP",
        which.phantom = "EFP",
        which.precision = c("all"),
        color.begin = 0.1,
        color.end = 0.5,
        point.alpha = 0.1,
        jitter.width = 0.1,
        show.rms.statistic = T)

# TODO. Ensure that more than one variable exists when grouping data with group.by. 

```











